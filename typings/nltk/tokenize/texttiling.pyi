"""
This type stub file was generated by pyright.
"""

from nltk.tokenize.api import TokenizerI
from typing import Any, Optional

DEFAULT_SMOOTHING = [0]
class TextTilingTokenizer(TokenizerI):
    """Tokenize a document into topical sections using the TextTiling algorithm.
    This algorithm detects subtopic shifts based on the analysis of lexical
    co-occurrence patterns.

    The process starts by tokenizing the text into pseudosentences of
    a fixed size w. Then, depending on the method used, similarity
    scores are assigned at sentence gaps. The algorithm proceeds by
    detecting the peak differences between these scores and marking
    them as boundaries. The boundaries are normalized to the closest
    paragraph break and the segmented text is returned.

    :param w: Pseudosentence size
    :type w: int
    :param k: Size (in sentences) of the block used in the block comparison method
    :type k: int
    :param similarity_method: The method used for determining similarity scores:
       `BLOCK_COMPARISON` (default) or `VOCABULARY_INTRODUCTION`.
    :type similarity_method: constant
    :param stopwords: A list of stopwords that are filtered out (defaults to NLTK's stopwords corpus)
    :type stopwords: list(str)
    :param smoothing_method: The method used for smoothing the score plot:
      `DEFAULT_SMOOTHING` (default)
    :type smoothing_method: constant
    :param smoothing_width: The width of the window used by the smoothing method
    :type smoothing_width: int
    :param smoothing_rounds: The number of smoothing passes
    :type smoothing_rounds: int
    :param cutoff_policy: The policy used to determine the number of boundaries:
      `HC` (default) or `LC`
    :type cutoff_policy: constant

    >>> from nltk.corpus import brown
    >>> tt = TextTilingTokenizer(demo_mode=True)
    >>> text = brown.raw()[:4000]
    >>> s, ss, d, b = tt.tokenize(text)
    >>> b
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0]
    """
    def __init__(self, w=..., k=..., similarity_method=..., stopwords: Optional[Any] = ..., smoothing_method=..., smoothing_width=..., smoothing_rounds=..., cutoff_policy=..., demo_mode: bool = ...):
        ...
    
    def tokenize(self, text):
        """Return a tokenized copy of *text*, where each "token" represents
        a separate topic."""
        ...
    
    def _block_comparison(self, tokseqs, token_table):
        """Implements the block comparison method"""
        ...
    
    def _smooth_scores(self, gap_scores):
        "Wraps the smooth function from the SciPy Cookbook"
        ...
    
    def _mark_paragraph_breaks(self, text):
        """Identifies indented text or line breaks as the beginning of
        paragraphs"""
        ...
    
    def _divide_to_tokensequences(self, text):
        "Divides the text into pseudosentences of fixed size"
        ...
    
    def _create_token_table(self, token_sequences, par_breaks):
        "Creates a table of TokenTableFields"
        ...
    
    def _identify_boundaries(self, depth_scores):
        """Identifies boundaries at the peaks of similarity score
        differences"""
        ...
    
    def _depth_scores(self, scores):
        """Calculates the depth of each gap, i.e. the average difference
        between the left and right peaks and the gap's score"""
        ...
    
    def _normalize_boundaries(self, text, boundaries, paragraph_breaks):
        """Normalize the boundaries identified to the original text's
        paragraph breaks"""
        ...
    


class TokenTableField(object):
    """A field in the token table holding parameters for each token,
    used later in the process"""
    def __init__(self, first_pos, ts_occurences, total_count=..., par_count=..., last_par=..., last_tok_seq: Optional[Any] = ...):
        ...
    


class TokenSequence(object):
    "A token list with its original length and its index"
    def __init__(self, index, wrdindex_list, original_length: Optional[Any] = ...):
        ...
    


def smooth(x, window_len=..., window=...):
    """smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal
    (with the window size) in both ends so that transient parts are minimized
    in the beginning and end part of the output signal.

    :param x: the input signal
    :param window_len: the dimension of the smoothing window; should be an odd integer
    :param window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
        flat window will produce a moving average smoothing.

    :return: the smoothed signal

    example::

        t=linspace(-2,2,0.1)
        x=sin(t)+randn(len(t))*0.1
        y=smooth(x)

    :see also: numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve,
        scipy.signal.lfilter

    TODO: the window parameter could be the window itself if an array instead of a string
    """
    ...

def demo(text: Optional[Any] = ...):
    ...

