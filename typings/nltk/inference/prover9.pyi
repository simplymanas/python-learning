"""
This type stub file was generated by pyright.
"""

from nltk.inference.api import BaseProverCommand, Prover
from typing import Any, Optional

"""
A theorem prover that makes use of the external 'Prover9' package.
"""
p9_return_codes = { 0: True,1: "(FATAL)",2: False,3: "(MAX_MEGS)",4: "(MAX_SECONDS)",5: "(MAX_GIVEN)",6: "(MAX_KEPT)",7: "(ACTION)",101: "(SIGSEGV)" }
class Prover9CommandParent(object):
    """
    A common base class used by both ``Prover9Command`` and ``MaceCommand``,
    which is responsible for maintaining a goal and a set of assumptions,
    and generating prover9-style input files from them.
    """
    def print_assumptions(self, output_format=...):
        """
        Print the list of the current assumptions.
        """
        ...
    


class Prover9Command(Prover9CommandParent, BaseProverCommand):
    """
    A ``ProverCommand`` specific to the ``Prover9`` prover.  It contains
    the a print_assumptions() method that is used to print the list
    of assumptions in multiple formats.
    """
    def __init__(self, goal: Optional[Any] = ..., assumptions: Optional[Any] = ..., timeout=..., prover: Optional[Any] = ...):
        """
        :param goal: Input expression to prove
        :type goal: sem.Expression
        :param assumptions: Input expressions to use as assumptions in
            the proof.
        :type assumptions: list(sem.Expression)
        :param timeout: number of seconds before timeout; set to 0 for
            no timeout.
        :type timeout: int
        :param prover: a prover.  If not set, one will be created.
        :type prover: Prover9
        """
        ...
    
    def decorate_proof(self, proof_string, simplify: bool = ...):
        """
        :see BaseProverCommand.decorate_proof()
        """
        ...
    


class Prover9Parent(object):
    """
    A common class extended by both ``Prover9`` and ``Mace <mace.Mace>``.
    It contains the functionality required to convert NLTK-style
    expressions into Prover9-style expressions.
    """
    _binary_location = ...
    def config_prover9(self, binary_location, verbose: bool = ...):
        ...
    
    def prover9_input(self, goal, assumptions):
        """
        :return: The input string that should be provided to the
        prover9 binary.  This string is formed based on the goal,
        assumptions, and timeout value of this object.
        """
        ...
    
    def binary_locations(self):
        """
        A list of directories that should be searched for the prover9
        executables.  This list is used by ``config_prover9`` when searching
        for the prover9 executables.
        """
        ...
    
    def _find_binary(self, name, verbose: bool = ...):
        ...
    
    def _call(self, input_str, binary, args=..., verbose: bool = ...):
        """
        Call the binary with the given input.

        :param input_str: A string whose contents are used as stdin.
        :param binary: The location of the binary to call
        :param args: A list of command-line arguments.
        :return: A tuple (stdout, returncode)
        :see: ``config_prover9``
        """
        ...
    


def convert_to_prover9(input):
    """
    Convert a ``logic.Expression`` to Prover9 format.
    """
    ...

def _convert_to_prover9(expression):
    """
    Convert ``logic.Expression`` to Prover9 formatted string.
    """
    ...

class Prover9(Prover9Parent, Prover):
    _prover9_bin = ...
    _prooftrans_bin = ...
    def __init__(self, timeout=...):
        ...
    
    def _prove(self, goal: Optional[Any] = ..., assumptions: Optional[Any] = ..., verbose: bool = ...):
        """
        Use Prover9 to prove a theorem.
        :return: A pair whose first element is a boolean indicating if the
        proof was successful (i.e. returns value of 0) and whose second element
        is the output of the prover.
        """
        ...
    
    def prover9_input(self, goal, assumptions):
        """
        :see: Prover9Parent.prover9_input
        """
        ...
    
    def _call_prover9(self, input_str, args=..., verbose: bool = ...):
        """
        Call the ``prover9`` binary with the given input.

        :param input_str: A string whose contents are used as stdin.
        :param args: A list of command-line arguments.
        :return: A tuple (stdout, returncode)
        :see: ``config_prover9``
        """
        ...
    
    def _call_prooftrans(self, input_str, args=..., verbose: bool = ...):
        """
        Call the ``prooftrans`` binary with the given input.

        :param input_str: A string whose contents are used as stdin.
        :param args: A list of command-line arguments.
        :return: A tuple (stdout, returncode)
        :see: ``config_prover9``
        """
        ...
    


class Prover9Exception(Exception):
    def __init__(self, returncode, message):
        ...
    


class Prover9FatalException(Prover9Exception):
    ...


class Prover9LimitExceededException(Prover9Exception):
    ...


def test_config():
    ...

def test_convert_to_prover9(expr):
    """
    Test that parsing works OK.
    """
    ...

def test_prove(arguments):
    """
    Try some proofs and exhibit the results.
    """
    ...

arguments = [('(man(x) <-> (not (not man(x))))', []), ('(not (man(x) & (not man(x))))', []), ('(man(x) | (not man(x)))', []), ('(man(x) & (not man(x)))', []), ('(man(x) -> man(x))', []), ('(not (man(x) & (not man(x))))', []), ('(man(x) | (not man(x)))', []), ('(man(x) -> man(x))', []), ('(man(x) <-> man(x))', []), ('(not (man(x) <-> (not man(x))))', []), ('mortal(Socrates)', ['all x.(man(x) -> mortal(x))', 'man(Socrates)']), ('((all x.(man(x) -> walks(x)) & man(Socrates)) -> some y.walks(y))', []), ('(all x.man(x) -> all x.man(x))', []), ('some x.all y.sees(x,y)', []), ('some e3.(walk(e3) & subj(e3, mary))', ['some e1.(see(e1) & subj(e1, john) & some e2.(pred(e1, e2) & walk(e2) & subj(e2, mary)))']), ('some x e1.(see(e1) & subj(e1, x) & some e2.(pred(e1, e2) & walk(e2) & subj(e2, mary)))', ['some e1.(see(e1) & subj(e1, john) & some e2.(pred(e1, e2) & walk(e2) & subj(e2, mary)))'])]
expressions = [r'some x y.sees(x,y)', r'some x.(man(x) & walks(x))', r'\x.(man(x) & walks(x))', r'\x y.sees(x,y)', r'walks(john)', r'\x.big(x, \y.mouse(y))', r'(walks(x) & (runs(x) & (threes(x) & fours(x))))', r'(walks(x) -> runs(x))', r'some x.(PRO(x) & sees(John, x))', r'some x.(man(x) & (not walks(x)))', r'all x.(man(x) -> walks(x))']
def spacer(num=...):
    ...

def demo():
    ...

if __name__ == '__main__':
    ...
