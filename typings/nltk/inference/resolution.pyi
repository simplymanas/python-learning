"""
This type stub file was generated by pyright.
"""

from nltk.inference.api import BaseProverCommand, Prover
from nltk.compat import python_2_unicode_compatible
from typing import Any, Optional

"""
Module for a resolution-based First Order theorem prover.
"""
class ProverParseError(Exception):
    ...


class ResolutionProver(Prover):
    ANSWER_KEY = ...
    _assume_false = ...
    def _prove(self, goal: Optional[Any] = ..., assumptions: Optional[Any] = ..., verbose: bool = ...):
        """
        :param goal: Input expression to prove
        :type goal: sem.Expression
        :param assumptions: Input expressions to use as assumptions in the proof
        :type assumptions: list(sem.Expression)
        """
        ...
    
    def _attempt_proof(self, clauses):
        ...
    


class ResolutionProverCommand(BaseProverCommand):
    def __init__(self, goal: Optional[Any] = ..., assumptions: Optional[Any] = ..., prover: Optional[Any] = ...):
        """
        :param goal: Input expression to prove
        :type goal: sem.Expression
        :param assumptions: Input expressions to use as assumptions in
            the proof.
        :type assumptions: list(sem.Expression)
        """
        ...
    
    def prove(self, verbose: bool = ...):
        """
        Perform the actual proof.  Store the result to prevent unnecessary
        re-proving.
        """
        ...
    
    def find_answers(self, verbose: bool = ...):
        ...
    
    @staticmethod
    def _decorate_clauses(clauses):
        """
        Decorate the proof output.
        """
        ...
    


@python_2_unicode_compatible
class Clause(list):
    def __init__(self, data):
        ...
    
    def unify(self, other, bindings: Optional[Any] = ..., used: Optional[Any] = ..., skipped: Optional[Any] = ..., debug: bool = ...):
        """
        Attempt to unify this Clause with the other, returning a list of
        resulting, unified, Clauses.

        :param other: ``Clause`` with which to unify
        :param bindings: ``BindingDict`` containing bindings that should be used
        during the unification
        :param used: tuple of two lists of atoms.  The first lists the
        atoms from 'self' that were successfully unified with atoms from
        'other'.  The second lists the atoms from 'other' that were successfully
        unified with atoms from 'self'.
        :param skipped: tuple of two ``Clause`` objects.  The first is a list of all
        the atoms from the 'self' Clause that have not been unified with
        anything on the path.  The second is same thing for the 'other' Clause.
        :param debug: bool indicating whether debug statements should print
        :return: list containing all the resulting ``Clause`` objects that could be
        obtained by unification
        """
        ...
    
    def isSubsetOf(self, other):
        """
        Return True iff every term in 'self' is a term in 'other'.

        :param other: ``Clause``
        :return: bool
        """
        ...
    
    def subsumes(self, other):
        """
        Return True iff 'self' subsumes 'other', this is, if there is a
        substitution such that every term in 'self' can be unified with a term
        in 'other'.

        :param other: ``Clause``
        :return: bool
        """
        ...
    
    def __getslice__(self, start, end):
        ...
    
    def __sub__(self, other):
        ...
    
    def __add__(self, other):
        ...
    
    def is_tautology(self):
        """
        Self is a tautology if it contains ground terms P and -P.  The ground
        term, P, must be an exact match, ie, not using unification.
        """
        ...
    
    def free(self):
        ...
    
    def replace(self, variable, expression):
        """
        Replace every instance of variable with expression across every atom
        in the clause

        :param variable: ``Variable``
        :param expression: ``Expression``
        """
        ...
    
    def substitute_bindings(self, bindings):
        """
        Replace every binding

        :param bindings: A list of tuples mapping Variable Expressions to the
        Expressions to which they are bound
        :return: ``Clause``
        """
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    


def _iterate_first(first, second, bindings, used, skipped, finalize_method, debug):
    """
    This method facilitates movement through the terms of 'self'
    """
    ...

def _iterate_second(first, second, bindings, used, skipped, finalize_method, debug):
    """
    This method facilitates movement through the terms of 'other'
    """
    ...

def _unify_terms(a, b, bindings: Optional[Any] = ..., used: Optional[Any] = ...):
    """
    This method attempts to unify two terms.  Two expressions are unifiable
    if there exists a substitution function S such that S(a) == S(-b).

    :param a: ``Expression``
    :param b: ``Expression``
    :param bindings: ``BindingDict`` a starting set of bindings with which
    the unification must be consistent
    :return: ``BindingDict`` A dictionary of the bindings required to unify
    :raise ``BindingException``: If the terms cannot be unified
    """
    ...

def _complete_unify_path(first, second, bindings, used, skipped, debug):
    ...

def _subsumes_finalize(first, second, bindings, used, skipped, debug):
    ...

def clausify(expression):
    """
    Skolemize, clausify, and standardize the variables apart.
    """
    ...

def _clausify(expression):
    """
    :param expression: a skolemized expression in CNF
    """
    ...

@python_2_unicode_compatible
class BindingDict(object):
    def __init__(self, binding_list: Optional[Any] = ...):
        """
        :param binding_list: list of (``AbstractVariableExpression``, ``AtomicExpression``) to initialize the dictionary
        """
        self.d = ...
    
    def __setitem__(self, variable, binding):
        """
        A binding is consistent with the dict if its variable is not already bound, OR if its
        variable is already bound to its argument.

        :param variable: ``Variable`` The variable to bind
        :param binding: ``Expression`` The atomic to which 'variable' should be bound
        :raise BindingException: If the variable cannot be bound in this dictionary
        """
        ...
    
    def __getitem__(self, variable):
        """
        Return the expression to which 'variable' is bound
        """
        ...
    
    def __contains__(self, item):
        ...
    
    def __add__(self, other):
        """
        :param other: ``BindingDict`` The dict with which to combine self
        :return: ``BindingDict`` A new dict containing all the elements of both parameters
        :raise BindingException: If the parameter dictionaries are not consistent with each other
        """
        ...
    
    def __len__(self):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    


def most_general_unification(a, b, bindings: Optional[Any] = ...):
    """
    Find the most general unification of the two given expressions

    :param a: ``Expression``
    :param b: ``Expression``
    :param bindings: ``BindingDict`` a starting set of bindings with which the
                     unification must be consistent
    :return: a list of bindings
    :raise BindingException: if the Expressions cannot be unified
    """
    ...

def _mgu_var(var, expression, bindings):
    ...

class BindingException(Exception):
    def __init__(self, arg):
        ...
    


class UnificationException(Exception):
    def __init__(self, a, b):
        ...
    


class DebugObject(object):
    def __init__(self, enabled: bool = ..., indent=...):
        self.enabled = ...
        self.indent = ...
    
    def __add__(self, i):
        ...
    
    def line(self, line):
        ...
    


def testResolutionProver():
    ...

def resolution_test(e):
    ...

def test_clausify():
    ...

def demo():
    ...

if __name__ == '__main__':
    ...
