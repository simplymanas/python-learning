"""
This type stub file was generated by pyright.
"""

from nltk.parse import ParserI
from nltk.parse.chart import AbstractChartRule, Chart, EdgeI
from nltk.ccg.lexicon import fromstring
from nltk.ccg.combinator import BackwardApplication, BackwardBx, BackwardComposition, BackwardSx, ForwardApplication, ForwardComposition, ForwardSubstitution
from nltk.compat import python_2_unicode_compatible
from nltk.ccg.logic import *
from nltk.sem.logic import *

"""
The lexicon is constructed by calling
``lexicon.fromstring(<lexicon string>)``.

In order to construct a parser, you also need a rule set.
The standard English rules are provided in chart as
``chart.DefaultRuleSet``.

The parser can then be constructed by calling, for example:
``parser = chart.CCGChartParser(<lexicon>, <ruleset>)``

Parsing is then performed by running
``parser.parse(<sentence>.split())``.

While this returns a list of trees, the default representation
of the produced trees is not very enlightening, particularly
given that it uses the same tree class as the CFG parsers.
It is probably better to call:
``chart.printCCGDerivation(<parse tree extracted from list>)``
which should print a nice representation of the derivation.

This entire process is shown far more clearly in the demonstration:
python chart.py
"""
class CCGEdge(EdgeI):
    def __init__(self, span, categ, rule):
        ...
    
    def lhs(self):
        ...
    
    def span(self):
        ...
    
    def start(self):
        ...
    
    def end(self):
        ...
    
    def length(self):
        ...
    
    def rhs(self):
        ...
    
    def dot(self):
        ...
    
    def is_complete(self):
        ...
    
    def is_incomplete(self):
        ...
    
    def nextsym(self):
        ...
    
    def categ(self):
        ...
    
    def rule(self):
        ...
    


class CCGLeafEdge(EdgeI):
    '''
    Class representing leaf edges in a CCG derivation.
    '''
    def __init__(self, pos, token, leaf):
        ...
    
    def lhs(self):
        ...
    
    def span(self):
        ...
    
    def start(self):
        ...
    
    def end(self):
        ...
    
    def length(self):
        ...
    
    def rhs(self):
        ...
    
    def dot(self):
        ...
    
    def is_complete(self):
        ...
    
    def is_incomplete(self):
        ...
    
    def nextsym(self):
        ...
    
    def token(self):
        ...
    
    def categ(self):
        ...
    
    def leaf(self):
        ...
    


@python_2_unicode_compatible
class BinaryCombinatorRule(AbstractChartRule):
    '''
    Class implementing application of a binary combinator to a chart.
    Takes the directed combinator to apply.
    '''
    NUMEDGES = ...
    def __init__(self, combinator):
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self):
        ...
    


@python_2_unicode_compatible
class ForwardTypeRaiseRule(AbstractChartRule):
    '''
    Class for applying forward type raising
    '''
    NUMEDGES = ...
    def __init__(self):
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self):
        ...
    


@python_2_unicode_compatible
class BackwardTypeRaiseRule(AbstractChartRule):
    '''
    Class for applying backward type raising.
    '''
    NUMEDGES = ...
    def __init__(self):
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self):
        ...
    


ApplicationRuleSet = [BinaryCombinatorRule(ForwardApplication), BinaryCombinatorRule(BackwardApplication)]
CompositionRuleSet = [BinaryCombinatorRule(ForwardComposition), BinaryCombinatorRule(BackwardComposition), BinaryCombinatorRule(BackwardBx)]
SubstitutionRuleSet = [BinaryCombinatorRule(ForwardSubstitution), BinaryCombinatorRule(BackwardSx)]
TypeRaiseRuleSet = [ForwardTypeRaiseRule(), BackwardTypeRaiseRule()]
DefaultRuleSet = ApplicationRuleSet + CompositionRuleSet + SubstitutionRuleSet + TypeRaiseRuleSet
class CCGChartParser(ParserI):
    '''
    Chart parser for CCGs.
    Based largely on the ChartParser class from NLTK.
    '''
    def __init__(self, lexicon, rules, trace=...):
        ...
    
    def lexicon(self):
        ...
    
    def parse(self, tokens):
        ...
    


class CCGChart(Chart):
    def __init__(self, tokens):
        ...
    
    def _trees(self, edge, complete, memo, tree_class):
        ...
    


def compute_semantics(children, edge):
    ...

def printCCGDerivation(tree):
    ...

def printCCGTree(lwidth, tree):
    ...

lex = fromstring('''
    :- S, NP, N, VP    # Primitive categories, S is the target primitive

    Det :: NP/N         # Family of words
    Pro :: NP
    TV :: VP/NP
    Modal :: (S\\NP)/VP # Backslashes need to be escaped

    I => Pro             # Word -> Category mapping
    you => Pro

    the => Det

    # Variables have the special keyword 'var'
    # '.' prevents permutation
    # ',' prevents composition
    and => var\\.,var/.,var

    which => (N\\N)/(S/NP)

    will => Modal # Categories can be either explicit, or families.
    might => Modal

    cook => TV
    eat => TV

    mushrooms => N
    parsnips => N
    bacon => N
    ''')
def demo():
    ...

if __name__ == '__main__':
    ...
