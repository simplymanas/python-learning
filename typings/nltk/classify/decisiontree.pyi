"""
This type stub file was generated by pyright.
"""

from nltk.classify.api import ClassifierI
from nltk.compat import python_2_unicode_compatible
from typing import Any, Optional

"""
A classifier model that decides which label to assign to a token on
the basis of a tree structure, where branches correspond to conditions
on feature values, and leaves correspond to label assignments.
"""
@python_2_unicode_compatible
class DecisionTreeClassifier(ClassifierI):
    def __init__(self, label, feature_name: Optional[Any] = ..., decisions: Optional[Any] = ..., default: Optional[Any] = ...):
        """
        :param label: The most likely label for tokens that reach
            this node in the decision tree.  If this decision tree
            has no children, then this label will be assigned to
            any token that reaches this decision tree.
        :param feature_name: The name of the feature that this
            decision tree selects for.
        :param decisions: A dictionary mapping from feature values
            for the feature identified by ``feature_name`` to
            child decision trees.
        :param default: The child that will be used if the value of
            feature ``feature_name`` does not match any of the keys in
            ``decisions``.  This is used when constructing binary
            decision trees.
        """
        ...
    
    def labels(self):
        ...
    
    def classify(self, featureset):
        ...
    
    def error(self, labeled_featuresets):
        ...
    
    def pretty_format(self, width=..., prefix=..., depth=...):
        """
        Return a string containing a pretty-printed version of this
        decision tree.  Each line in this string corresponds to a
        single decision tree node or leaf, and indentation is used to
        display the structure of the decision tree.
        """
        ...
    
    def pseudocode(self, prefix=..., depth=...):
        """
        Return a string representation of this decision tree that
        expresses the decisions it makes as a nested set of pseudocode
        if statements.
        """
        ...
    
    def __str__(self):
        ...
    
    @staticmethod
    def train(labeled_featuresets, entropy_cutoff=..., depth_cutoff=..., support_cutoff=..., binary: bool = ..., feature_values: Optional[Any] = ..., verbose: bool = ...):
        """
        :param binary: If true, then treat all feature/value pairs as
            individual binary features, rather than using a single n-way
            branch for each feature.
        """
        ...
    
    @staticmethod
    def leaf(labeled_featuresets):
        ...
    
    @staticmethod
    def stump(feature_name, labeled_featuresets):
        ...
    
    def refine(self, labeled_featuresets, entropy_cutoff, depth_cutoff, support_cutoff, binary: bool = ..., feature_values: Optional[Any] = ..., verbose: bool = ...):
        ...
    
    @staticmethod
    def best_stump(feature_names, labeled_featuresets, verbose: bool = ...):
        ...
    
    @staticmethod
    def binary_stump(feature_name, feature_value, labeled_featuresets):
        ...
    
    @staticmethod
    def best_binary_stump(feature_names, labeled_featuresets, feature_values, verbose: bool = ...):
        ...
    


def f(x):
    ...

def demo():
    ...

if __name__ == '__main__':
    ...
