"""
This type stub file was generated by pyright.
"""

import threading
from nltk.compat import python_2_unicode_compatible
from typing import Any, Optional
from optparse import OptionParser

"""
The NLTK corpus and module downloader.  This module defines several
interfaces which can be used to download corpora, models, and other
data packages that can be used with NLTK.

Downloading Packages
====================
If called with no arguments, ``download()`` will display an interactive
interface which can be used to download and install new packages.
If Tkinter is available, then a graphical interface will be shown,
otherwise a simple text interface will be provided.

Individual packages can be downloaded by calling the ``download()``
function with a single argument, giving the package identifier for the
package that should be downloaded:

    >>> download('treebank') # doctest: +SKIP
    [nltk_data] Downloading package 'treebank'...
    [nltk_data]   Unzipping corpora/treebank.zip.

NLTK also provides a number of \"package collections\", consisting of
a group of related packages.  To download all packages in a
colleciton, simply call ``download()`` with the collection's
identifier:

    >>> download('all-corpora') # doctest: +SKIP
    [nltk_data] Downloading package 'abc'...
    [nltk_data]   Unzipping corpora/abc.zip.
    [nltk_data] Downloading package 'alpino'...
    [nltk_data]   Unzipping corpora/alpino.zip.
      ...
    [nltk_data] Downloading package 'words'...
    [nltk_data]   Unzipping corpora/words.zip.

Download Directory
==================
By default, packages are installed in either a system-wide directory
(if Python has sufficient access to write to it); or in the current
user's home directory.  However, the ``download_dir`` argument may be
used to specify a different installation target, if desired.

See ``Downloader.default_download_dir()`` for more a detailed
description of how the default download directory is chosen.

NLTK Download Server
====================
Before downloading any packages, the corpus and module downloader
contacts the NLTK download server, to retrieve an index file
describing the available packages.  By default, this index file is
loaded from ``https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml``.
If necessary, it is possible to create a new ``Downloader`` object,
specifying a different URL for the package index file.

Usage::

    python nltk/downloader.py [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS

or::

    python -m nltk.downloader [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS
"""
@python_2_unicode_compatible
class Package(object):
    """
    A directory entry for a downloadable package.  These entries are
    extracted from the XML index file that is downloaded by
    ``Downloader``.  Each package consists of a single file; but if
    that file is a zip file, then it can be automatically decompressed
    when the package is installed.
    """
    def __init__(self, id, url, name: Optional[Any] = ..., subdir=..., size: Optional[Any] = ..., unzipped_size: Optional[Any] = ..., checksum: Optional[Any] = ..., svn_revision: Optional[Any] = ..., copyright=..., contact=..., license=..., author=..., unzip: bool = ..., **kw):
        self.id = ...
        self.name = ...
        self.subdir = ...
        self.url = ...
        self.size = ...
        self.unzipped_size = ...
        self.checksum = ...
        self.svn_revision = ...
        self.copyright = ...
        self.contact = ...
        self.license = ...
        self.author = ...
        self.filename = ...
        self.unzip = ...
    
    @staticmethod
    def fromxml(xml):
        ...
    
    def __lt__(self, other):
        ...
    
    def __repr__(self):
        ...
    


@python_2_unicode_compatible
class Collection(object):
    """
    A directory entry for a collection of downloadable packages.
    These entries are extracted from the XML index file that is
    downloaded by ``Downloader``.
    """
    def __init__(self, id, children, name: Optional[Any] = ..., **kw):
        self.id = ...
        self.name = ...
        self.children = ...
        self.packages = ...
    
    @staticmethod
    def fromxml(xml):
        ...
    
    def __lt__(self, other):
        ...
    
    def __repr__(self):
        ...
    


class DownloaderMessage(object):
    """A status message object, used by ``incr_download`` to
       communicate its progress."""
    ...


class StartCollectionMessage(DownloaderMessage):
    """Data server has started working on a collection of packages."""
    def __init__(self, collection):
        self.collection = ...
    


class FinishCollectionMessage(DownloaderMessage):
    """Data server has finished working on a collection of packages."""
    def __init__(self, collection):
        self.collection = ...
    


class StartPackageMessage(DownloaderMessage):
    """Data server has started working on a package."""
    def __init__(self, package):
        self.package = ...
    


class FinishPackageMessage(DownloaderMessage):
    """Data server has finished working on a package."""
    def __init__(self, package):
        self.package = ...
    


class StartDownloadMessage(DownloaderMessage):
    """Data server has started downloading a package."""
    def __init__(self, package):
        self.package = ...
    


class FinishDownloadMessage(DownloaderMessage):
    """Data server has finished downloading a package."""
    def __init__(self, package):
        self.package = ...
    


class StartUnzipMessage(DownloaderMessage):
    """Data server has started unzipping a package."""
    def __init__(self, package):
        self.package = ...
    


class FinishUnzipMessage(DownloaderMessage):
    """Data server has finished unzipping a package."""
    def __init__(self, package):
        self.package = ...
    


class UpToDateMessage(DownloaderMessage):
    """The package download file is already up-to-date"""
    def __init__(self, package):
        self.package = ...
    


class StaleMessage(DownloaderMessage):
    """The package download file is out-of-date or corrupt"""
    def __init__(self, package):
        self.package = ...
    


class ErrorMessage(DownloaderMessage):
    """Data server encountered an error"""
    def __init__(self, package, message):
        self.package = ...
    


class ProgressMessage(DownloaderMessage):
    """Indicates how much progress the data server has made"""
    def __init__(self, progress):
        self.progress = ...
    


class SelectDownloadDirMessage(DownloaderMessage):
    """Indicates what download directory the data server is using"""
    def __init__(self, download_dir):
        self.download_dir = ...
    


class Downloader(object):
    """
    A class used to access the NLTK data server, which can be used to
    download corpora and other data packages.
    """
    INDEX_TIMEOUT = ...
    DEFAULT_URL = ...
    INSTALLED = ...
    NOT_INSTALLED = ...
    STALE = ...
    PARTIAL = ...
    def __init__(self, server_index_url: Optional[Any] = ..., download_dir: Optional[Any] = ...):
        ...
    
    def list(self, download_dir: Optional[Any] = ..., show_packages: bool = ..., show_collections: bool = ..., header: bool = ..., more_prompt: bool = ..., skip_installed: bool = ...):
        ...
    
    def packages(self):
        ...
    
    def corpora(self):
        ...
    
    def models(self):
        ...
    
    def collections(self):
        ...
    
    def _info_or_id(self, info_or_id):
        ...
    
    def incr_download(self, info_or_id, download_dir: Optional[Any] = ..., force: bool = ...):
        ...
    
    def _num_packages(self, item):
        ...
    
    def _download_list(self, items, download_dir, force):
        ...
    
    def _download_package(self, info, download_dir, force):
        ...
    
    def download(self, info_or_id: Optional[Any] = ..., download_dir: Optional[Any] = ..., quiet: bool = ..., force: bool = ..., prefix=..., halt_on_error: bool = ..., raise_on_error: bool = ..., print_error_to=...):
        ...
    
    def is_stale(self, info_or_id, download_dir: Optional[Any] = ...):
        ...
    
    def is_installed(self, info_or_id, download_dir: Optional[Any] = ...):
        ...
    
    def clear_status_cache(self, id: Optional[Any] = ...):
        ...
    
    def status(self, info_or_id, download_dir: Optional[Any] = ...):
        """
        Return a constant describing the status of the given package
        or collection.  Status can be one of ``INSTALLED``,
        ``NOT_INSTALLED``, ``STALE``, or ``PARTIAL``.
        """
        ...
    
    def _pkg_status(self, info, filepath):
        ...
    
    def update(self, quiet: bool = ..., prefix=...):
        """
        Re-download any packages whose status is STALE.
        """
        ...
    
    def _update_index(self, url: Optional[Any] = ...):
        """A helper function that ensures that self._index is
        up-to-date.  If the index is older than self.INDEX_TIMEOUT,
        then download it again."""
        ...
    
    def index(self):
        """
        Return the XML index describing the packages available from
        the data server.  If necessary, this index will be downloaded
        from the data server.
        """
        ...
    
    def info(self, id):
        """Return the ``Package`` or ``Collection`` record for the
           given item."""
        ...
    
    def xmlinfo(self, id):
        """Return the XML info record for the given item"""
        ...
    
    def _get_url(self):
        """The URL for the data server's index file."""
        ...
    
    def _set_url(self, url):
        """
        Set a new URL for the data server. If we're unable to contact
        the given url, then the original url is kept.
        """
        ...
    
    url = ...
    def default_download_dir(self):
        """
        Return the directory to which packages will be downloaded by
        default.  This value can be overridden using the constructor,
        or on a case-by-case basis using the ``download_dir`` argument when
        calling ``download()``.

        On Windows, the default download directory is
        ``PYTHONHOME/lib/nltk``, where *PYTHONHOME* is the
        directory containing Python, e.g. ``C:\\Python25``.

        On all other platforms, the default directory is the first of
        the following which exists or which can be created with write
        permission: ``/usr/share/nltk_data``, ``/usr/local/share/nltk_data``,
        ``/usr/lib/nltk_data``, ``/usr/local/lib/nltk_data``, ``~/nltk_data``.
        """
        ...
    
    def _get_download_dir(self):
        """
        The default directory to which packages will be downloaded.
        This defaults to the value returned by ``default_download_dir()``.
        To override this default on a case-by-case basis, use the
        ``download_dir`` argument when calling ``download()``.
        """
        ...
    
    def _set_download_dir(self, download_dir):
        ...
    
    download_dir = ...
    def _interactive_download(self):
        ...
    


class DownloaderShell(object):
    def __init__(self, dataserver):
        ...
    
    def _simple_interactive_menu(self, *options):
        ...
    
    def run(self):
        ...
    
    def _simple_interactive_download(self, args):
        ...
    
    def _simple_interactive_update(self):
        ...
    
    def _simple_interactive_help(self):
        ...
    
    def _show_config(self):
        ...
    
    def _simple_interactive_config(self):
        ...
    


class DownloaderGUI(object):
    """
    Graphical interface for downloading packages from the NLTK data
    server.
    """
    COLUMNS = ...
    COLUMN_WEIGHTS = ...
    COLUMN_WIDTHS = ...
    DEFAULT_COLUMN_WIDTH = ...
    INITIAL_COLUMNS = ...
    _BACKDROP_COLOR = ...
    _ROW_COLOR = ...
    _MARK_COLOR = ...
    _FRONT_TAB_COLOR = ...
    _BACK_TAB_COLOR = ...
    _PROGRESS_COLOR = ...
    _TAB_FONT = ...
    def __init__(self, dataserver, use_threads: bool = ...):
        ...
    
    def _log(self, msg):
        ...
    
    def _init_widgets(self):
        ...
    
    def _init_menu(self):
        ...
    
    def _select_columns(self):
        ...
    
    def _refresh(self):
        ...
    
    def _info_edit(self, info_key):
        ...
    
    def _info_save(self, e: Optional[Any] = ...):
        ...
    
    def _table_reprfunc(self, row, col, val):
        ...
    
    def _set_url(self, url):
        ...
    
    def _set_download_dir(self, download_dir):
        ...
    
    def _show_info(self):
        ...
    
    def _prev_tab(self, *e):
        ...
    
    def _next_tab(self, *e):
        ...
    
    def _select_tab(self, event):
        ...
    
    _tab = ...
    _rows = ...
    def _fill_table(self):
        ...
    
    def _update_table_status(self):
        ...
    
    def _download(self, *e):
        ...
    
    _DL_DELAY = ...
    def _download_cb(self, download_iter, ids):
        ...
    
    def _select(self, id):
        ...
    
    def _color_table(self):
        ...
    
    def _clear_mark(self, id):
        ...
    
    def _mark_all(self, *e):
        ...
    
    def _table_mark(self, *e):
        ...
    
    def _show_log(self):
        ...
    
    def _package_to_columns(self, pkg):
        """
        Given a package, return a list of values describing that
        package, one for each column in ``self.COLUMNS``.
        """
        ...
    
    def destroy(self, *e):
        ...
    
    def _destroy(self, *e):
        ...
    
    def mainloop(self, *args, **kwargs):
        ...
    
    HELP = ...
    def help(self, *e):
        ...
    
    def about(self, *e):
        ...
    
    _gradient_width = ...
    def _init_progressbar(self):
        ...
    
    def _show_progress(self, percent):
        ...
    
    def _progress_alive(self):
        ...
    
    def _download_threaded(self, *e):
        ...
    
    def _abort_download(self):
        ...
    
    class _DownloadThread(threading.Thread):
        def __init__(self, data_server, items, lock, message_queue, abort):
            self.data_server = ...
            self.items = ...
            self.lock = ...
            self.message_queue = ...
            self.abort = ...
        
        def run(self):
            ...
        
    
    
    _MONITOR_QUEUE_DELAY = ...
    def _monitor_message_queue(self):
        ...
    


def md5_hexdigest(file):
    """
    Calculate and return the MD5 checksum for a given file.
    ``file`` may either be a filename or an open stream.
    """
    ...

def _md5_hexdigest(fp):
    ...

def unzip(filename, root, verbose: bool = ...):
    """
    Extract the contents of the zip file ``filename`` into the
    directory ``root``.
    """
    ...

def _unzip_iter(filename, root, verbose: bool = ...):
    ...

def build_index(root, base_url):
    """
    Create a new data.xml index file, by combining the xml description
    files for various packages and collections.  ``root`` should be the
    path to a directory containing the package xml and zip files; and
    the collection xml files.  The ``root`` directory is expected to
    have the following subdirectories::

      root/
        packages/ .................. subdirectory for packages
          corpora/ ................. zip & xml files for corpora
          grammars/ ................ zip & xml files for grammars
          taggers/ ................. zip & xml files for taggers
          tokenizers/ .............. zip & xml files for tokenizers
          etc.
        collections/ ............... xml files for collections

    For each package, there should be two files: ``package.zip``
    (where *package* is the package name)
    which contains the package itself as a compressed zip file; and
    ``package.xml``, which is an xml description of the package.  The
    zipfile ``package.zip`` should expand to a single subdirectory
    named ``package/``.  The base filename ``package`` must match
    the identifier given in the package's xml file.

    For each collection, there should be a single file ``collection.zip``
    describing the collection, where *collection* is the name of the collection.

    All identifiers (for both packages and collections) must be unique.
    """
    ...

def _indent_xml(xml, prefix=...):
    """
    Helper for ``build_index()``: Given an XML ``ElementTree``, modify it
    (and its descendents) ``text`` and ``tail`` attributes to generate
    an indented tree, where each nested element is indented by 2
    spaces with respect to its parent.
    """
    ...

def _check_package(pkg_xml, zipfilename, zf):
    """
    Helper for ``build_index()``: Perform some checks to make sure that
    the given package is consistent.
    """
    ...

def _svn_revision(filename):
    """
    Helper for ``build_index()``: Calculate the subversion revision
    number for a given file (by using ``subprocess`` to run ``svn``).
    """
    ...

def _find_collections(root):
    """
    Helper for ``build_index()``: Yield a list of ElementTree.Element
    objects, each holding the xml for a single package collection.
    """
    ...

def _find_packages(root):
    """
    Helper for ``build_index()``: Yield a list of tuples
    ``(pkg_xml, zf, subdir)``, where:
      - ``pkg_xml`` is an ``ElementTree.Element`` holding the xml for a
        package
      - ``zf`` is a ``zipfile.ZipFile`` for the package's contents.
      - ``subdir`` is the subdirectory (relative to ``root``) where
        the package was found (e.g. 'corpora' or 'grammars').
    """
    ...

_downloader = Downloader()
download = _downloader.download
def download_shell():
    ...

def download_gui():
    ...

def update():
    ...

if __name__ == '__main__':
    parser = OptionParser()
    downloader = Downloader(server_index_url=options.server_index_url)
