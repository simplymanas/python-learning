"""
This type stub file was generated by pyright.
"""

import re
from functools import total_ordering
from nltk.corpus.reader import CorpusReader
from nltk.compat import python_2_unicode_compatible
from nltk.internals import deprecated
from typing import Any, Optional

"""
An NLTK interface for WordNet

WordNet is a lexical database of English.
Using synsets, helps find conceptual relationships between words
such as hypernyms, hyponyms, synonyms, antonyms etc.

For details about WordNet see:
http://wordnet.princeton.edu/

This module also allows you to find lemmas in languages
other than English from the Open Multilingual Wordnet
http://compling.hss.ntu.edu.sg/omw/

"""
_INF = 1e+300
POS_LIST = [NOUN, VERB, ADJ, ADV]
VERB_FRAME_STRINGS = (None, "Something %s", "Somebody %s", "It is %sing", "Something is %sing PP", "Something %s something Adjective/Noun", "Something %s Adjective/Noun", "Somebody %s Adjective", "Somebody %s something", "Somebody %s somebody", "Something %s somebody", "Something %s something", "Something %s to somebody", "Somebody %s on something", "Somebody %s somebody something", "Somebody %s something to somebody", "Somebody %s something from somebody", "Somebody %s somebody with something", "Somebody %s somebody of something", "Somebody %s something on somebody", "Somebody %s somebody PP", "Somebody %s something PP", "Somebody %s PP", "Somebody's (body part) %s", "Somebody %s somebody to INFINITIVE", "Somebody %s somebody INFINITIVE", "Somebody %s that CLAUSE", "Somebody %s to somebody", "Somebody %s to INFINITIVE", "Somebody %s whether INFINITIVE", "Somebody %s somebody into V-ing something", "Somebody %s something with something", "Somebody %s INFINITIVE", "Somebody %s VERB-ing", "It %s that CLAUSE", "Something %s INFINITIVE")
SENSENUM_RE = re.compile(r'\.[\d]+\.')
class WordNetError(Exception):
    """An exception class for wordnet-related errors."""
    ...


@total_ordering
class _WordNetObject(object):
    """A common base class for lemmas and synsets."""
    def hypernyms(self):
        ...
    
    def _hypernyms(self):
        ...
    
    def instance_hypernyms(self):
        ...
    
    def _instance_hypernyms(self):
        ...
    
    def hyponyms(self):
        ...
    
    def instance_hyponyms(self):
        ...
    
    def member_holonyms(self):
        ...
    
    def substance_holonyms(self):
        ...
    
    def part_holonyms(self):
        ...
    
    def member_meronyms(self):
        ...
    
    def substance_meronyms(self):
        ...
    
    def part_meronyms(self):
        ...
    
    def topic_domains(self):
        ...
    
    def in_topic_domains(self):
        ...
    
    def region_domains(self):
        ...
    
    def in_region_domains(self):
        ...
    
    def usage_domains(self):
        ...
    
    def in_usage_domains(self):
        ...
    
    def attributes(self):
        ...
    
    def entailments(self):
        ...
    
    def causes(self):
        ...
    
    def also_sees(self):
        ...
    
    def verb_groups(self):
        ...
    
    def similar_tos(self):
        ...
    
    def __hash__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __lt__(self, other):
        ...
    


@python_2_unicode_compatible
class Lemma(_WordNetObject):
    """
    The lexical entry for a single morphological form of a
    sense-disambiguated word.

    Create a Lemma from a "<word>.<pos>.<number>.<lemma>" string where:
    <word> is the morphological stem identifying the synset
    <pos> is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB
    <number> is the sense number, counting from 0.
    <lemma> is the morphological form of interest

    Note that <word> and <lemma> can be different, e.g. the Synset
    'salt.n.03' has the Lemmas 'salt.n.03.salt', 'salt.n.03.saltiness' and
    'salt.n.03.salinity'.

    Lemma attributes, accessible via methods with the same name:

    - name: The canonical name of this lemma.
    - synset: The synset that this lemma belongs to.
    - syntactic_marker: For adjectives, the WordNet string identifying the
      syntactic position relative modified noun. See:
      https://wordnet.princeton.edu/documentation/wninput5wn
      For all other parts of speech, this attribute is None.
    - count: The frequency of this lemma in wordnet.

    Lemma methods:

    Lemmas have the following methods for retrieving related Lemmas. They
    correspond to the names for the pointer symbols defined here:
    https://wordnet.princeton.edu/documentation/wninput5wn
    These methods all return lists of Lemmas:

    - antonyms
    - hypernyms, instance_hypernyms
    - hyponyms, instance_hyponyms
    - member_holonyms, substance_holonyms, part_holonyms
    - member_meronyms, substance_meronyms, part_meronyms
    - topic_domains, region_domains, usage_domains
    - attributes
    - derivationally_related_forms
    - entailments
    - causes
    - also_sees
    - verb_groups
    - similar_tos
    - pertainyms
    """
    __slots__ = ...
    def __init__(self, wordnet_corpus_reader, synset, name, lexname_index, lex_id, syntactic_marker):
        ...
    
    def name(self):
        ...
    
    def syntactic_marker(self):
        ...
    
    def synset(self):
        ...
    
    def frame_strings(self):
        ...
    
    def frame_ids(self):
        ...
    
    def lang(self):
        ...
    
    def key(self):
        ...
    
    def __repr__(self):
        ...
    
    def _related(self, relation_symbol):
        ...
    
    def count(self):
        """Return the frequency count for this Lemma"""
        ...
    
    def antonyms(self):
        ...
    
    def derivationally_related_forms(self):
        ...
    
    def pertainyms(self):
        ...
    


@python_2_unicode_compatible
class Synset(_WordNetObject):
    """Create a Synset from a "<lemma>.<pos>.<number>" string where:
    <lemma> is the word's morphological stem
    <pos> is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB
    <number> is the sense number, counting from 0.

    Synset attributes, accessible via methods with the same name:

    - name: The canonical name of this synset, formed using the first lemma
      of this synset. Note that this may be different from the name
      passed to the constructor if that string used a different lemma to
      identify the synset.
    - pos: The synset's part of speech, matching one of the module level
      attributes ADJ, ADJ_SAT, ADV, NOUN or VERB.
    - lemmas: A list of the Lemma objects for this synset.
    - definition: The definition for this synset.
    - examples: A list of example strings for this synset.
    - offset: The offset in the WordNet dict file of this synset.
    - lexname: The name of the lexicographer file containing this synset.

    Synset methods:

    Synsets have the following methods for retrieving related Synsets.
    They correspond to the names for the pointer symbols defined here:
    https://wordnet.princeton.edu/documentation/wninput5wn
    These methods all return lists of Synsets.

    - hypernyms, instance_hypernyms
    - hyponyms, instance_hyponyms
    - member_holonyms, substance_holonyms, part_holonyms
    - member_meronyms, substance_meronyms, part_meronyms
    - attributes
    - entailments
    - causes
    - also_sees
    - verb_groups
    - similar_tos

    Additionally, Synsets support the following methods specific to the
    hypernym relation:

    - root_hypernyms
    - common_hypernyms
    - lowest_common_hypernyms

    Note that Synsets do not support the following relations because
    these are defined by WordNet as lexical relations:

    - antonyms
    - derivationally_related_forms
    - pertainyms
    """
    __slots__ = ...
    def __init__(self, wordnet_corpus_reader):
        ...
    
    def pos(self):
        ...
    
    def offset(self):
        ...
    
    def name(self):
        ...
    
    def frame_ids(self):
        ...
    
    def definition(self):
        ...
    
    def examples(self):
        ...
    
    def lexname(self):
        ...
    
    def _needs_root(self):
        ...
    
    def lemma_names(self, lang=...):
        '''Return all the lemma_names associated with the synset'''
        ...
    
    def lemmas(self, lang=...):
        '''Return all the lemma objects associated with the synset'''
        ...
    
    def root_hypernyms(self):
        """Get the topmost hypernyms of this synset in WordNet."""
        ...
    
    def max_depth(self):
        """
        :return: The length of the longest hypernym path from this
        synset to the root.
        """
        ...
    
    def min_depth(self):
        """
        :return: The length of the shortest hypernym path from this
        synset to the root.
        """
        ...
    
    def closure(self, rel, depth=...):
        """Return the transitive closure of source under the rel
        relationship, breadth-first

            >>> from nltk.corpus import wordnet as wn
            >>> dog = wn.synset('dog.n.01')
            >>> hyp = lambda s:s.hypernyms()
            >>> list(dog.closure(hyp))
            [Synset('canine.n.02'), Synset('domestic_animal.n.01'),
            Synset('carnivore.n.01'), Synset('animal.n.01'),
            Synset('placental.n.01'), Synset('organism.n.01'),
            Synset('mammal.n.01'), Synset('living_thing.n.01'),
            Synset('vertebrate.n.01'), Synset('whole.n.02'),
            Synset('chordate.n.01'), Synset('object.n.01'),
            Synset('physical_entity.n.01'), Synset('entity.n.01')]

        """
        ...
    
    def hypernym_paths(self):
        """
        Get the path(s) from this synset to the root, where each path is a
        list of the synset nodes traversed on the way to the root.

        :return: A list of lists, where each list gives the node sequence
           connecting the initial ``Synset`` node and a root node.
        """
        ...
    
    def common_hypernyms(self, other):
        """
        Find all synsets that are hypernyms of this synset and the
        other synset.

        :type other: Synset
        :param other: other input synset.
        :return: The synsets that are hypernyms of both synsets.
        """
        ...
    
    def lowest_common_hypernyms(self, other, simulate_root: bool = ..., use_min_depth: bool = ...):
        """
        Get a list of lowest synset(s) that both synsets have as a hypernym.
        When `use_min_depth == False` this means that the synset which appears
        as a hypernym of both `self` and `other` with the lowest maximum depth
        is returned or if there are multiple such synsets at the same depth
        they are all returned

        However, if `use_min_depth == True` then the synset(s) which has/have
        the lowest minimum depth and appear(s) in both paths is/are returned.

        By setting the use_min_depth flag to True, the behavior of NLTK2 can be
        preserved. This was changed in NLTK3 to give more accurate results in a
        small set of cases, generally with synsets concerning people. (eg:
        'chef.n.01', 'fireman.n.01', etc.)

        This method is an implementation of Ted Pedersen's "Lowest Common
        Subsumer" method from the Perl Wordnet module. It can return either
        "self" or "other" if they are a hypernym of the other.

        :type other: Synset
        :param other: other input synset
        :type simulate_root: bool
        :param simulate_root: The various verb taxonomies do not
            share a single root which disallows this metric from working for
            synsets that are not connected. This flag (False by default)
            creates a fake root that connects all the taxonomies. Set it
            to True to enable this behavior. For the noun taxonomy,
            there is usually a default root except for WordNet version 1.6.
            If you are using wordnet 1.6, a fake root will need to be added
            for nouns as well.
        :type use_min_depth: bool
        :param use_min_depth: This setting mimics older (v2) behavior of NLTK
            wordnet If True, will use the min_depth function to calculate the
            lowest common hypernyms. This is known to give strange results for
            some synset pairs (eg: 'chef.n.01', 'fireman.n.01') but is retained
            for backwards compatibility
        :return: The synsets that are the lowest common hypernyms of both
            synsets
        """
        ...
    
    def hypernym_distances(self, distance=..., simulate_root: bool = ...):
        """
        Get the path(s) from this synset to the root, counting the distance
        of each node from the initial node on the way. A set of
        (synset, distance) tuples is returned.

        :type distance: int
        :param distance: the distance (number of edges) from this hypernym to
            the original hypernym ``Synset`` on which this method was called.
        :return: A set of ``(Synset, int)`` tuples where each ``Synset`` is
           a hypernym of the first ``Synset``.
        """
        ...
    
    def _shortest_hypernym_paths(self, simulate_root):
        ...
    
    def shortest_path_distance(self, other, simulate_root: bool = ...):
        """
        Returns the distance of the shortest path linking the two synsets (if
        one exists). For each synset, all the ancestor nodes and their
        distances are recorded and compared. The ancestor node common to both
        synsets that can be reached with the minimum number of traversals is
        used. If no ancestor nodes are common, None is returned. If a node is
        compared with itself 0 is returned.

        :type other: Synset
        :param other: The Synset to which the shortest path will be found.
        :return: The number of edges in the shortest path connecting the two
            nodes, or None if no path exists.
        """
        ...
    
    def tree(self, rel, depth=..., cut_mark: Optional[Any] = ...):
        """
        >>> from nltk.corpus import wordnet as wn
        >>> dog = wn.synset('dog.n.01')
        >>> hyp = lambda s:s.hypernyms()
        >>> from pprint import pprint
        >>> pprint(dog.tree(hyp))
        [Synset('dog.n.01'),
         [Synset('canine.n.02'),
          [Synset('carnivore.n.01'),
           [Synset('placental.n.01'),
            [Synset('mammal.n.01'),
             [Synset('vertebrate.n.01'),
              [Synset('chordate.n.01'),
               [Synset('animal.n.01'),
                [Synset('organism.n.01'),
                 [Synset('living_thing.n.01'),
                  [Synset('whole.n.02'),
                   [Synset('object.n.01'),
                    [Synset('physical_entity.n.01'),
                     [Synset('entity.n.01')]]]]]]]]]]]]],
         [Synset('domestic_animal.n.01'),
          [Synset('animal.n.01'),
           [Synset('organism.n.01'),
            [Synset('living_thing.n.01'),
             [Synset('whole.n.02'),
              [Synset('object.n.01'),
               [Synset('physical_entity.n.01'), [Synset('entity.n.01')]]]]]]]]]
        """
        ...
    
    def path_similarity(self, other, verbose: bool = ..., simulate_root: bool = ...):
        """
        Path Distance Similarity:
        Return a score denoting how similar two word senses are, based on the
        shortest path that connects the senses in the is-a (hypernym/hypnoym)
        taxonomy. The score is in the range 0 to 1, except in those cases where
        a path cannot be found (will only be true for verbs as there are many
        distinct verb taxonomies), in which case None is returned. A score of
        1 represents identity i.e. comparing a sense with itself will return 1.

        :type other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type simulate_root: bool
        :param simulate_root: The various verb taxonomies do not
            share a single root which disallows this metric from working for
            synsets that are not connected. This flag (True by default)
            creates a fake root that connects all the taxonomies. Set it
            to false to disable this behavior. For the noun taxonomy,
            there is usually a default root except for WordNet version 1.6.
            If you are using wordnet 1.6, a fake root will be added for nouns
            as well.
        :return: A score denoting the similarity of the two ``Synset`` objects,
            normally between 0 and 1. None is returned if no connecting path
            could be found. 1 is returned if a ``Synset`` is compared with
            itself.
        """
        ...
    
    def lch_similarity(self, other, verbose: bool = ..., simulate_root: bool = ...):
        """
        Leacock Chodorow Similarity:
        Return a score denoting how similar two word senses are, based on the
        shortest path that connects the senses (as above) and the maximum depth
        of the taxonomy in which the senses occur. The relationship is given as
        -log(p/2d) where p is the shortest path length and d is the taxonomy
        depth.

        :type  other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type simulate_root: bool
        :param simulate_root: The various verb taxonomies do not
            share a single root which disallows this metric from working for
            synsets that are not connected. This flag (True by default)
            creates a fake root that connects all the taxonomies. Set it
            to false to disable this behavior. For the noun taxonomy,
            there is usually a default root except for WordNet version 1.6.
            If you are using wordnet 1.6, a fake root will be added for nouns
            as well.
        :return: A score denoting the similarity of the two ``Synset`` objects,
            normally greater than 0. None is returned if no connecting path
            could be found. If a ``Synset`` is compared with itself, the
            maximum score is returned, which varies depending on the taxonomy
            depth.
        """
        ...
    
    def wup_similarity(self, other, verbose: bool = ..., simulate_root: bool = ...):
        """
        Wu-Palmer Similarity:
        Return a score denoting how similar two word senses are, based on the
        depth of the two senses in the taxonomy and that of their Least Common
        Subsumer (most specific ancestor node). Previously, the scores computed
        by this implementation did _not_ always agree with those given by
        Pedersen's Perl implementation of WordNet Similarity. However, with
        the addition of the simulate_root flag (see below), the score for
        verbs now almost always agree but not always for nouns.

        The LCS does not necessarily feature in the shortest path connecting
        the two senses, as it is by definition the common ancestor deepest in
        the taxonomy, not closest to the two senses. Typically, however, it
        will so feature. Where multiple candidates for the LCS exist, that
        whose shortest path to the root node is the longest will be selected.
        Where the LCS has multiple paths to the root, the longer path is used
        for the purposes of the calculation.

        :type  other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type simulate_root: bool
        :param simulate_root: The various verb taxonomies do not
            share a single root which disallows this metric from working for
            synsets that are not connected. This flag (True by default)
            creates a fake root that connects all the taxonomies. Set it
            to false to disable this behavior. For the noun taxonomy,
            there is usually a default root except for WordNet version 1.6.
            If you are using wordnet 1.6, a fake root will be added for nouns
            as well.
        :return: A float score denoting the similarity of the two ``Synset``
            objects, normally greater than zero. If no connecting path between
            the two senses can be found, None is returned.

        """
        ...
    
    def res_similarity(self, other, ic, verbose: bool = ...):
        """
        Resnik Similarity:
        Return a score denoting how similar two word senses are, based on the
        Information Content (IC) of the Least Common Subsumer (most specific
        ancestor node).

        :type  other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type ic: dict
        :param ic: an information content object (as returned by
            ``nltk.corpus.wordnet_ic.ic()``).
        :return: A float score denoting the similarity of the two ``Synset``
            objects. Synsets whose LCS is the root node of the taxonomy will
            have a score of 0 (e.g. N['dog'][0] and N['table'][0]).
        """
        ...
    
    def jcn_similarity(self, other, ic, verbose: bool = ...):
        """
        Jiang-Conrath Similarity:
        Return a score denoting how similar two word senses are, based on the
        Information Content (IC) of the Least Common Subsumer (most specific
        ancestor node) and that of the two input Synsets. The relationship is
        given by the equation 1 / (IC(s1) + IC(s2) - 2 * IC(lcs)).

        :type  other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type  ic: dict
        :param ic: an information content object (as returned by
            ``nltk.corpus.wordnet_ic.ic()``).
        :return: A float score denoting the similarity of the two ``Synset``
            objects.
        """
        ...
    
    def lin_similarity(self, other, ic, verbose: bool = ...):
        """
        Lin Similarity:
        Return a score denoting how similar two word senses are, based on the
        Information Content (IC) of the Least Common Subsumer (most specific
        ancestor node) and that of the two input Synsets. The relationship is
        given by the equation 2 * IC(lcs) / (IC(s1) + IC(s2)).

        :type other: Synset
        :param other: The ``Synset`` that this ``Synset`` is being compared to.
        :type ic: dict
        :param ic: an information content object (as returned by
            ``nltk.corpus.wordnet_ic.ic()``).
        :return: A float score denoting the similarity of the two ``Synset``
            objects, in the range 0 to 1.
        """
        ...
    
    def _iter_hypernym_lists(self):
        """
        :return: An iterator over ``Synset`` objects that are either proper
        hypernyms or instance of hypernyms of the synset.
        """
        ...
    
    def __repr__(self):
        ...
    
    def _related(self, relation_symbol, sort: bool = ...):
        ...
    


class WordNetCorpusReader(CorpusReader):
    """
    A corpus reader used to access wordnet or its variants.
    """
    _ENCODING = ...
    _FILEMAP = ...
    _pos_numbers = ...
    _pos_names = ...
    _FILES = ...
    def __init__(self, root, omw_reader):
        """
        Construct a new wordnet corpus reader, with the given root
        directory.
        """
        ...
    
    def of2ss(self, of):
        ''' take an id and return the synsets '''
        ...
    
    def ss2of(self, ss, lang: Optional[Any] = ...):
        ''' return the ID of the synset '''
        ...
    
    def _load_lang_data(self, lang):
        ''' load the wordnet data of the requested language from the file to
        the cache, _lang_data '''
        ...
    
    def langs(self):
        ''' return a list of languages supported by Multilingual Wordnet '''
        ...
    
    def _load_lemma_pos_offset_map(self):
        ...
    
    def _load_exception_map(self):
        ...
    
    def _compute_max_depth(self, pos, simulate_root):
        """
        Compute the max depth for the given part of speech.  This is
        used by the lch similarity metric.
        """
        ...
    
    def get_version(self):
        ...
    
    def lemma(self, name, lang=...):
        '''Return lemma object that matches the name'''
        ...
    
    def lemma_from_key(self, key):
        ...
    
    def synset(self, name):
        ...
    
    def _data_file(self, pos):
        """
        Return an open file pointer for the data file for the given
        part of speech.
        """
        ...
    
    def synset_from_pos_and_offset(self, pos, offset):
        ...
    
    @deprecated('Use public method synset_from_pos_and_offset() instead')
    def _synset_from_pos_and_offset(self, *args, **kwargs):
        """
        Hack to help people like the readers of
        http://stackoverflow.com/a/27145655/1709587
        who were using this function before it was officially a public method
        """
        ...
    
    def _synset_from_pos_and_line(self, pos, data_file_line):
        ...
    
    def synset_from_sense_key(self, sense_key):
        """
        Retrieves synset based on a given sense_key. Sense keys can be
        obtained from lemma.key()

        From https://wordnet.princeton.edu/documentation/senseidx5wn:
        A sense_key is represented as:
            lemma % lex_sense (e.g. 'dog%1:18:01::')
        where lex_sense is encoded as:
            ss_type:lex_filenum:lex_id:head_word:head_id

        lemma:       ASCII text of word/collocation, in lower case
        ss_type:     synset type for the sense (1 digit int)
                     The synset type is encoded as follows:
                     1    NOUN
                     2    VERB
                     3    ADJECTIVE
                     4    ADVERB
                     5    ADJECTIVE SATELLITE
        lex_filenum: name of lexicographer file containing the synset for the sense (2 digit int)
        lex_id:      when paired with lemma, uniquely identifies a sense in the lexicographer file (2 digit int)
        head_word:   lemma of the first word in satellite's head synset
                     Only used if sense is in an adjective satellite synset
        head_id:     uniquely identifies sense in a lexicographer file when paired with head_word
                     Only used if head_word is present (2 digit int)
        """
        ...
    
    def synsets(self, lemma, pos: Optional[Any] = ..., lang=..., check_exceptions: bool = ...):
        """Load all synsets with a given lemma and part of speech tag.
        If no pos is specified, all synsets for all parts of speech
        will be loaded.
        If lang is specified, all the synsets associated with the lemma name
        of that language will be returned.
        """
        ...
    
    def lemmas(self, lemma, pos: Optional[Any] = ..., lang=...):
        """Return all Lemma objects with a name matching the specified lemma
        name and part of speech tag. Matches any part of speech tag if none is
        specified."""
        ...
    
    def all_lemma_names(self, pos: Optional[Any] = ..., lang=...):
        """Return all lemma names for all synsets for the given
        part of speech tag and language or languages. If pos is
        not specified, all synsets for all parts of speech will
        be used."""
        ...
    
    def all_synsets(self, pos: Optional[Any] = ...):
        """Iterate over all synsets with a given part of speech tag.
        If no pos is specified, all synsets for all parts of speech
        will be loaded.
        """
        ...
    
    def words(self, lang=...):
        """return lemmas of the given language as list of words"""
        ...
    
    def license(self, lang=...):
        """Return the contents of LICENSE (for omw)
           use lang=lang to get the license for an individual language"""
        ...
    
    def readme(self, lang=...):
        """Return the contents of README (for omw)
           use lang=lang to get the readme for an individual language"""
        ...
    
    def citation(self, lang=...):
        """Return the contents of citation.bib file (for omw)
           use lang=lang to get the citation for an individual language"""
        ...
    
    def lemma_count(self, lemma):
        """Return the frequency count for this Lemma"""
        ...
    
    def path_similarity(self, synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
        ...
    
    def lch_similarity(self, synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
        ...
    
    def wup_similarity(self, synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
        ...
    
    def res_similarity(self, synset1, synset2, ic, verbose: bool = ...):
        ...
    
    def jcn_similarity(self, synset1, synset2, ic, verbose: bool = ...):
        ...
    
    def lin_similarity(self, synset1, synset2, ic, verbose: bool = ...):
        ...
    
    def morphy(self, form, pos: Optional[Any] = ..., check_exceptions: bool = ...):
        """
        Find a possible base form for the given form, with the given
        part of speech, by checking WordNet's list of exceptional
        forms, and by recursively stripping affixes for this part of
        speech until a form in WordNet is found.

        >>> from nltk.corpus import wordnet as wn
        >>> print(wn.morphy('dogs'))
        dog
        >>> print(wn.morphy('churches'))
        church
        >>> print(wn.morphy('aardwolves'))
        aardwolf
        >>> print(wn.morphy('abaci'))
        abacus
        >>> wn.morphy('hardrock', wn.ADV)
        >>> print(wn.morphy('book', wn.NOUN))
        book
        >>> wn.morphy('book', wn.ADJ)
        """
        ...
    
    MORPHOLOGICAL_SUBSTITUTIONS = ...
    def _morphy(self, form, pos, check_exceptions: bool = ...):
        ...
    
    def ic(self, corpus, weight_senses_equally: bool = ..., smoothing=...):
        """
        Creates an information content lookup dictionary from a corpus.

        :type corpus: CorpusReader
        :param corpus: The corpus from which we create an information
        content dictionary.
        :type weight_senses_equally: bool
        :param weight_senses_equally: If this is True, gives all
        possible senses equal weight rather than dividing by the
        number of possible senses.  (If a word has 3 synses, each
        sense gets 0.3333 per appearance when this is False, 1.0 when
        it is true.)
        :param smoothing: How much do we smooth synset counts (default is 1.0)
        :type smoothing: float
        :return: An information content dictionary
        """
        ...
    
    def custom_lemmas(self, tab_file, lang):
        """
        Reads a custom tab file containing mappings of lemmas in the given
        language to Princeton WordNet 3.0 synset offsets, allowing NLTK's
        WordNet functions to then be used with that language.

        See the "Tab files" section at http://compling.hss.ntu.edu.sg/omw/ for
        documentation on the Multilingual WordNet tab file format.

        :param tab_file: Tab file as a file or file-like object
        :type  lang str
        :param lang ISO 639-3 code of the language of the tab file
        """
        ...
    


class WordNetICCorpusReader(CorpusReader):
    """
    A corpus reader for the WordNet information content corpus.
    """
    def __init__(self, root, fileids):
        ...
    
    def ic(self, icfile):
        """
        Load an information content file from the wordnet_ic corpus
        and return a dictionary.  This dictionary has just two keys,
        NOUN and VERB, whose values are dictionaries that map from
        synsets to information content values.

        :type icfile: str
        :param icfile: The name of the wordnet_ic file (e.g. "ic-brown.dat")
        :return: An information content dictionary
        """
        ...
    


def path_similarity(synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
    ...

def lch_similarity(synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
    ...

def wup_similarity(synset1, synset2, verbose: bool = ..., simulate_root: bool = ...):
    ...

def res_similarity(synset1, synset2, ic, verbose: bool = ...):
    ...

def jcn_similarity(synset1, synset2, ic, verbose: bool = ...):
    ...

def lin_similarity(synset1, synset2, ic, verbose: bool = ...):
    ...

def _lcs_ic(synset1, synset2, ic, verbose: bool = ...):
    """
    Get the information content of the least common subsumer that has
    the highest information content value.  If two nodes have no
    explicit common subsumer, assume that they share an artificial
    root node that is the hypernym of all explicit roots.

    :type synset1: Synset
    :param synset1: First input synset.
    :type synset2: Synset
    :param synset2: Second input synset.  Must be the same part of
    speech as the first synset.
    :type  ic: dict
    :param ic: an information content object (as returned by ``load_ic()``).
    :return: The information content of the two synsets and their most
    informative subsumer
    """
    ...

def information_content(synset, ic):
    ...

def _get_pos(field):
    ...

def teardown_module(module: Optional[Any] = ...):
    ...

