"""
This type stub file was generated by pyright.
"""

from nltk.compat import python_2_unicode_compatible
from nltk.sem.logic import AbstractVariableExpression, ApplicationExpression, BinaryExpression, BooleanExpression, ConstantExpression, EqualityExpression, EventVariableExpression, Expression, FunctionVariableExpression, IndividualVariableExpression, LambdaExpression, LogicParser, NegatedExpression, OrExpression, Tokens
from typing import Any, Optional

class DrtTokens(Tokens):
    DRS = ...
    DRS_CONC = ...
    PRONOUN = ...
    OPEN_BRACKET = ...
    CLOSE_BRACKET = ...
    COLON = ...
    PUNCT = ...
    SYMBOLS = ...
    TOKENS = ...


class DrtParser(LogicParser):
    """A lambda calculus expression parser."""
    def __init__(self):
        self.operator_precedence = ...
    
    def get_all_symbols(self):
        """This method exists to be overridden"""
        ...
    
    def isvariable(self, tok):
        ...
    
    def handle(self, tok, context):
        """This method is intended to be overridden for logics that
        use different operators or expressions"""
        ...
    
    def make_NegatedExpression(self, expression):
        ...
    
    def handle_DRS(self, tok, context):
        ...
    
    def handle_refs(self):
        ...
    
    def handle_conds(self, context):
        ...
    
    def handle_prop(self, tok, context):
        ...
    
    def make_EqualityExpression(self, first, second):
        """This method serves as a hook for other logic parsers that
        have different equality expression classes"""
        ...
    
    def get_BooleanExpression_factory(self, tok):
        """This method serves as a hook for other logic parsers that
        have different boolean operators"""
        ...
    
    def make_BooleanExpression(self, factory, first, second):
        ...
    
    def make_ApplicationExpression(self, function, argument):
        ...
    
    def make_VariableExpression(self, name):
        ...
    
    def make_LambdaExpression(self, variables, term):
        ...
    


class DrtExpression(object):
    """
    This is the base abstract DRT Expression from which every DRT
    Expression extends.
    """
    _drt_parser = ...
    @classmethod
    def fromstring(cls, s):
        ...
    
    def applyto(self, other):
        ...
    
    def __neg__(self):
        ...
    
    def __and__(self, other):
        ...
    
    def __or__(self, other):
        ...
    
    def __gt__(self, other):
        ...
    
    def equiv(self, other, prover: Optional[Any] = ...):
        """
        Check for logical equivalence.
        Pass the expression (self <-> other) to the theorem prover.
        If the prover says it is valid, then the self and other are equal.

        :param other: an ``DrtExpression`` to check equality against
        :param prover: a ``nltk.inference.api.Prover``
        """
        ...
    
    @property
    def type(self):
        ...
    
    def typecheck(self, signature: Optional[Any] = ...):
        ...
    
    def __add__(self, other):
        ...
    
    def get_refs(self, recursive: bool = ...):
        """
        Return the set of discourse referents in this DRS.
        :param recursive: bool Also find discourse referents in subterms?
        :return: list of ``Variable`` objects
        """
        ...
    
    def is_pronoun_function(self):
        """ Is self of the form "PRO(x)"? """
        ...
    
    def make_EqualityExpression(self, first, second):
        ...
    
    def make_VariableExpression(self, variable):
        ...
    
    def resolve_anaphora(self):
        ...
    
    def eliminate_equality(self):
        ...
    
    def pretty_format(self):
        """
        Draw the DRS
        :return: the pretty print string
        """
        ...
    
    def pretty_print(self):
        ...
    
    def draw(self):
        ...
    


@python_2_unicode_compatible
class DRS(DrtExpression, Expression):
    """A Discourse Representation Structure."""
    def __init__(self, refs, conds, consequent: Optional[Any] = ...):
        """
        :param refs: list of ``DrtIndividualVariableExpression`` for the
        discourse referents
        :param conds: list of ``Expression`` for the conditions
        """
        self.refs = ...
        self.conds = ...
        self.consequent = ...
    
    def replace(self, variable, expression, replace_bound: bool = ..., alpha_convert: bool = ...):
        """Replace all instances of variable v with expression E in self,
        where v is free in self."""
        ...
    
    def free(self):
        """:see: Expression.free()"""
        ...
    
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def visit(self, function, combinator):
        """:see: Expression.visit()"""
        ...
    
    def visit_structured(self, function, combinator):
        """:see: Expression.visit_structured()"""
        ...
    
    def eliminate_equality(self):
        ...
    
    def fol(self):
        ...
    
    def _pretty(self):
        ...
    
    def _order_ref_strings(self, refs):
        ...
    
    def __eq__(self, other):
        r"""Defines equality modulo alphabetic variance.
        If we are comparing \x.M  and \y.N, then check equality of M and N[x/y]."""
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...
    def __str__(self):
        ...
    


def DrtVariableExpression(variable):
    """
    This is a factory method that instantiates and returns a subtype of
    ``DrtAbstractVariableExpression`` appropriate for the given variable.
    """
    ...

class DrtAbstractVariableExpression(DrtExpression, AbstractVariableExpression):
    def fol(self):
        ...
    
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def _pretty(self):
        ...
    
    def eliminate_equality(self):
        ...
    


class DrtIndividualVariableExpression(DrtAbstractVariableExpression, IndividualVariableExpression):
    ...


class DrtFunctionVariableExpression(DrtAbstractVariableExpression, FunctionVariableExpression):
    ...


class DrtEventVariableExpression(DrtIndividualVariableExpression, EventVariableExpression):
    ...


class DrtConstantExpression(DrtAbstractVariableExpression, ConstantExpression):
    ...


@python_2_unicode_compatible
class DrtProposition(DrtExpression, Expression):
    def __init__(self, variable, drs):
        self.variable = ...
        self.drs = ...
    
    def replace(self, variable, expression, replace_bound: bool = ..., alpha_convert: bool = ...):
        ...
    
    def eliminate_equality(self):
        ...
    
    def get_refs(self, recursive: bool = ...):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...
    def fol(self):
        ...
    
    def _pretty(self):
        ...
    
    def visit(self, function, combinator):
        """:see: Expression.visit()"""
        ...
    
    def visit_structured(self, function, combinator):
        """:see: Expression.visit_structured()"""
        ...
    
    def __str__(self):
        ...
    


class DrtNegatedExpression(DrtExpression, NegatedExpression):
    def fol(self):
        ...
    
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def _pretty(self):
        ...
    


class DrtLambdaExpression(DrtExpression, LambdaExpression):
    def alpha_convert(self, newvar):
        """Rename all occurrences of the variable introduced by this variable
        binder in the expression to ``newvar``.
        :param newvar: ``Variable``, for the new variable
        """
        ...
    
    def fol(self):
        ...
    
    def _pretty(self):
        ...
    


class DrtBinaryExpression(DrtExpression, BinaryExpression):
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def _pretty(self):
        ...
    
    @staticmethod
    def _assemble_pretty(first_lines, op, second_lines):
        ...
    
    def _pretty_subex(self, subex):
        ...
    


class DrtBooleanExpression(DrtBinaryExpression, BooleanExpression):
    ...


class DrtOrExpression(DrtBooleanExpression, OrExpression):
    def fol(self):
        ...
    
    def _pretty_subex(self, subex):
        ...
    


class DrtEqualityExpression(DrtBinaryExpression, EqualityExpression):
    def fol(self):
        ...
    


@python_2_unicode_compatible
class DrtConcatenation(DrtBooleanExpression):
    """DRS of the form '(DRS + DRS)'"""
    def __init__(self, first, second, consequent: Optional[Any] = ...):
        self.consequent = ...
    
    def replace(self, variable, expression, replace_bound: bool = ..., alpha_convert: bool = ...):
        """Replace all instances of variable v with expression E in self,
        where v is free in self."""
        ...
    
    def eliminate_equality(self):
        ...
    
    def simplify(self):
        ...
    
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def getOp(self):
        ...
    
    def __eq__(self, other):
        r"""Defines equality modulo alphabetic variance.
        If we are comparing \x.M  and \y.N, then check equality of M and N[x/y]."""
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...
    def fol(self):
        ...
    
    def _pretty(self):
        ...
    
    def _pretty_subex(self, subex):
        ...
    
    def visit(self, function, combinator):
        """:see: Expression.visit()"""
        ...
    
    def __str__(self):
        ...
    
    def _str_subex(self, subex):
        ...
    


class DrtApplicationExpression(DrtExpression, ApplicationExpression):
    def fol(self):
        ...
    
    def get_refs(self, recursive: bool = ...):
        """:see: AbstractExpression.get_refs()"""
        ...
    
    def _pretty(self):
        ...
    


def _pad_vertically(lines, max_lines):
    ...

@python_2_unicode_compatible
class PossibleAntecedents(list, DrtExpression, Expression):
    def free(self):
        """Set of free variables."""
        ...
    
    def replace(self, variable, expression, replace_bound: bool = ..., alpha_convert: bool = ...):
        """Replace all instances of variable v with expression E in self,
        where v is free in self."""
        ...
    
    def _pretty(self):
        ...
    
    def __str__(self):
        ...
    


class AnaphoraResolutionException(Exception):
    ...


def resolve_anaphora(expression, trail=...):
    ...

class DrsDrawer(object):
    BUFFER = ...
    TOPSPACE = ...
    OUTERSPACE = ...
    def __init__(self, drs, size_canvas: bool = ..., canvas: Optional[Any] = ...):
        """
        :param drs: ``DrtExpression``, The DRS to be drawn
        :param size_canvas: bool, True if the canvas size should be the exact size of the DRS
        :param canvas: ``Canvas`` The canvas on which to draw the DRS.  If none is given, create a new canvas.
        """
        self.canvas = ...
        self.drs = ...
        self.master = ...
    
    def _get_text_height(self):
        """Get the height of a line of text"""
        ...
    
    def draw(self, x=..., y=...):
        """Draw the DRS"""
        ...
    
    def _visit(self, expression, x, y):
        """
        Return the bottom-rightmost point without actually drawing the item

        :param expression: the item to visit
        :param x: the top of the current drawing area
        :param y: the left side of the current drawing area
        :return: the bottom-rightmost point
        """
        ...
    
    def _draw_command(self, item, x, y):
        """
        Draw the given item at the given location

        :param item: the item to draw
        :param x: the top of the current drawing area
        :param y: the left side of the current drawing area
        :return: the bottom-rightmost point
        """
        ...
    
    def _visit_command(self, item, x, y):
        """
        Return the bottom-rightmost point without actually drawing the item

        :param item: the item to visit
        :param x: the top of the current drawing area
        :param y: the left side of the current drawing area
        :return: the bottom-rightmost point
        """
        ...
    
    def _handle(self, expression, command, x=..., y=...):
        """
        :param expression: the expression to handle
        :param command: the function to apply, either _draw_command or _visit_command
        :param x: the top of the current drawing area
        :param y: the left side of the current drawing area
        :return: the bottom-rightmost point
        """
        ...
    
    def _handle_VariableExpression(self, expression, command, x, y):
        ...
    
    def _handle_NegatedExpression(self, expression, command, x, y):
        ...
    
    def _handle_DRS(self, expression, command, x, y):
        ...
    
    def _handle_ApplicationExpression(self, expression, command, x, y):
        ...
    
    def _handle_LambdaExpression(self, expression, command, x, y):
        ...
    
    def _handle_BinaryExpression(self, expression, command, x, y):
        ...
    
    def _handle_DrtProposition(self, expression, command, x, y):
        ...
    
    def _get_centered_top(self, top, full_height, item_height):
        """Get the y-coordinate of the point that a figure should start at if
        its height is 'item_height' and it needs to be centered in an area that
        starts at 'top' and is 'full_height' tall."""
        ...
    


def demo():
    ...

def test_draw():
    ...

if __name__ == '__main__':
    ...
