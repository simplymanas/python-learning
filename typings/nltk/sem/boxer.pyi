"""
This type stub file was generated by pyright.
"""

from optparse import OptionParser
from nltk.sem.drt import DrtParser
from nltk.compat import python_2_unicode_compatible
from typing import Any, Optional

"""
An interface to Boxer.

This interface relies on the latest version of the development (subversion) version of
C&C and Boxer.

Usage:
  Set the environment variable CANDC to the bin directory of your CandC installation.
  The models directory should be in the CandC root directory.
  For example:
     /path/to/candc/
        bin/
            candc
            boxer
        models/
            boxer/
"""
class Boxer(object):
    """
    This class is an interface to Johan Bos's program Boxer, a wide-coverage
    semantic parser that produces Discourse Representation Structures (DRSs).
    """
    def __init__(self, boxer_drs_interpreter: Optional[Any] = ..., elimeq: bool = ..., bin_dir: Optional[Any] = ..., verbose: bool = ..., resolve: bool = ...):
        """
        :param boxer_drs_interpreter: A class that converts from the
        ``AbstractBoxerDrs`` object hierarchy to a different object.  The
        default is ``NltkDrtBoxerDrsInterpreter``, which converts to the NLTK
        DRT hierarchy.
        :param elimeq: When set to true, Boxer removes all equalities from the
        DRSs and discourse referents standing in the equality relation are
        unified, but only if this can be done in a meaning-preserving manner.
        :param resolve: When set to true, Boxer will resolve all anaphoric DRSs and perform merge-reduction.
        Resolution follows Van der Sandt's theory of binding and accommodation.
        """
        ...
    
    def set_bin_dir(self, bin_dir, verbose: bool = ...):
        ...
    
    def interpret(self, input, discourse_id: Optional[Any] = ..., question: bool = ..., verbose: bool = ...):
        """
        Use Boxer to give a first order representation.

        :param input: str Input sentence to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...
    
    def interpret_multi(self, input, discourse_id: Optional[Any] = ..., question: bool = ..., verbose: bool = ...):
        """
        Use Boxer to give a first order representation.

        :param input: list of str Input sentences to parse as a single discourse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...
    
    def interpret_sents(self, inputs, discourse_ids: Optional[Any] = ..., question: bool = ..., verbose: bool = ...):
        """
        Use Boxer to give a first order representation.

        :param inputs: list of str Input sentences to parse as individual discourses
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: list of ``drt.DrtExpression``
        """
        ...
    
    def interpret_multi_sents(self, inputs, discourse_ids: Optional[Any] = ..., question: bool = ..., verbose: bool = ...):
        """
        Use Boxer to give a first order representation.

        :param inputs: list of list of str Input discourses to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...
    
    def _call_candc(self, inputs, discourse_ids, question, verbose: bool = ...):
        """
        Call the ``candc`` binary with the given input.

        :param inputs: list of list of str Input discourses to parse
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :param filename: str A filename for the output file
        :return: stdout
        """
        ...
    
    def _call_boxer(self, candc_out, verbose: bool = ...):
        """
        Call the ``boxer`` binary with the given input.

        :param candc_out: str output from C&C parser
        :return: stdout
        """
        ...
    
    def _find_binary(self, name, bin_dir, verbose: bool = ...):
        ...
    
    def _call(self, input_str, binary, args=..., verbose: bool = ...):
        """
        Call the binary with the given input.

        :param input_str: A string whose contents are used as stdin.
        :param binary: The location of the binary to call
        :param args: A list of command-line arguments.
        :return: stdout
        """
        ...
    
    def _parse_to_drs_dict(self, boxer_out, use_disc_id):
        ...
    
    def _parse_drs(self, drs_string, discourse_id, use_disc_id):
        ...
    


class BoxerOutputDrsParser(DrtParser):
    def __init__(self, discourse_id: Optional[Any] = ...):
        """
        This class is used to parse the Prolog DRS output from Boxer into a
        hierarchy of python objects.
        """
        self.discourse_id = ...
        self.sentence_id_offset = ...
        self.quote_chars = ...
    
    def parse(self, data, signature: Optional[Any] = ...):
        ...
    
    def get_all_symbols(self):
        ...
    
    def handle(self, tok, context):
        ...
    
    def attempt_adjuncts(self, expression, context):
        ...
    
    def parse_condition(self, indices):
        """
        Parse a DRS condition

        :return: list of ``DrtExpression``
        """
        ...
    
    def handle_drs(self, tok):
        ...
    
    def handle_condition(self, tok, indices):
        """
        Handle a DRS condition

        :param indices: list of int
        :return: list of ``DrtExpression``
        """
        ...
    
    def _handle_not(self):
        ...
    
    def _handle_pred(self):
        ...
    
    def _handle_duplex(self):
        ...
    
    def _handle_named(self):
        ...
    
    def _handle_rel(self):
        ...
    
    def _handle_timex(self):
        ...
    
    def _handle_time_expression(self, arg):
        ...
    
    def _handle_date(self, arg):
        ...
    
    def _handle_time(self, arg):
        ...
    
    def _handle_card(self):
        ...
    
    def _handle_prop(self):
        ...
    
    def _parse_index_list(self):
        ...
    
    def parse_drs(self):
        ...
    
    def _handle_binary_expression(self, make_callback):
        ...
    
    def _handle_alfa(self, make_callback):
        ...
    
    def _handle_eq(self):
        ...
    
    def _handle_whq(self):
        ...
    
    def _make_merge_expression(self, sent_index, word_indices, drs1, drs2):
        ...
    
    def _make_or_expression(self, sent_index, word_indices, drs1, drs2):
        ...
    
    def _make_imp_expression(self, sent_index, word_indices, drs1, drs2):
        ...
    
    def parse_variable(self):
        ...
    
    def parse_index(self):
        ...
    
    def _sent_and_word_indices(self, indices):
        """
        :return: list of (sent_index, word_indices) tuples
        """
        ...
    


class BoxerDrsParser(DrtParser):
    """
    Reparse the str form of subclasses of ``AbstractBoxerDrs``
    """
    def __init__(self, discourse_id: Optional[Any] = ...):
        self.discourse_id = ...
    
    def get_all_symbols(self):
        ...
    
    def attempt_adjuncts(self, expression, context):
        ...
    
    def handle(self, tok, context):
        ...
    
    def nullableIntToken(self):
        ...
    
    def get_next_token_variable(self, description):
        ...
    


class AbstractBoxerDrs(object):
    def variables(self):
        """
        :return: (set<variables>, set<events>, set<propositions>)
        """
        ...
    
    def variable_types(self):
        ...
    
    def _variables(self):
        """
        :return: (set<variables>, set<events>, set<propositions>)
        """
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def _clean_name(self, name):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __hash__(self):
        ...
    


@python_2_unicode_compatible
class BoxerDrs(AbstractBoxerDrs):
    def __init__(self, refs, conds, consequent: Optional[Any] = ...):
        self.refs = ...
        self.conds = ...
        self.consequent = ...
    
    def _variables(self):
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...


@python_2_unicode_compatible
class BoxerNot(AbstractBoxerDrs):
    def __init__(self, drs):
        self.drs = ...
    
    def _variables(self):
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...


@python_2_unicode_compatible
class BoxerIndexed(AbstractBoxerDrs):
    def __init__(self, discourse_id, sent_index, word_indices):
        self.discourse_id = ...
        self.sent_index = ...
        self.word_indices = ...
    
    def atoms(self):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    __hash__ = ...
    def __repr__(self):
        ...
    


class BoxerPred(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, name, pos, sense):
        self.var = ...
        self.name = ...
        self.pos = ...
        self.sense = ...
    
    def _variables(self):
        ...
    
    def change_var(self, var):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerNamed(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, name, type, sense):
        self.var = ...
        self.name = ...
        self.type = ...
        self.sense = ...
    
    def _variables(self):
        ...
    
    def change_var(self, var):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerRel(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2, rel, sense):
        self.var1 = ...
        self.var2 = ...
        self.rel = ...
        self.sense = ...
    
    def _variables(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerProp(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, drs):
        self.var = ...
        self.drs = ...
    
    def _variables(self):
        ...
    
    def referenced_labels(self):
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerEq(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2):
        self.var1 = ...
        self.var2 = ...
    
    def _variables(self):
        ...
    
    def atoms(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerCard(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, value, type):
        self.var = ...
        self.value = ...
        self.type = ...
    
    def _variables(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerOr(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, drs1, drs2):
        self.drs1 = ...
        self.drs2 = ...
    
    def _variables(self):
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class BoxerWhq(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, ans_types, drs1, variable, drs2):
        self.ans_types = ...
        self.drs1 = ...
        self.variable = ...
        self.drs2 = ...
    
    def _variables(self):
        ...
    
    def atoms(self):
        ...
    
    def clean(self):
        ...
    
    def renumber_sentences(self, f):
        ...
    
    def __iter__(self):
        ...
    
    def _pred(self):
        ...
    


class PassthroughBoxerDrsInterpreter(object):
    def interpret(self, ex):
        ...
    


class NltkDrtBoxerDrsInterpreter(object):
    def __init__(self, occur_index: bool = ...):
        ...
    
    def interpret(self, ex):
        """
        :param ex: ``AbstractBoxerDrs``
        :return: ``DrtExpression``
        """
        ...
    
    def _make_atom(self, pred, *args):
        ...
    
    def _add_occur_indexing(self, base, ex):
        ...
    


class UnparseableInputException(Exception):
    ...


if __name__ == '__main__':
    opts = OptionParser("usage: %prog TEXT [options]")
    interpreter = NltkDrtBoxerDrsInterpreter(occur_index=options.occur_index)
    drs = Boxer(interpreter).interpret_multi(args[0].split(r'\n'), question=options.question, verbose=options.verbose)
