"""
This type stub file was generated by pyright.
"""

from nltk.internals import Counter
from nltk.compat import python_2_unicode_compatible
from nltk.sem.logic import LogicParser
from typing import Any, Optional

_counter = Counter()
class Tokens(object):
    OPEN = ...
    CLOSE = ...
    IMP = ...
    PUNCT = ...
    TOKENS = ...


class LinearLogicParser(LogicParser):
    """A linear logic expression parser."""
    def __init__(self):
        self.operator_precedence = ...
    
    def get_all_symbols(self):
        ...
    
    def handle(self, tok, context):
        ...
    
    def get_BooleanExpression_factory(self, tok):
        ...
    
    def make_BooleanExpression(self, factory, first, second):
        ...
    
    def attempt_ApplicationExpression(self, expression, context):
        """Attempt to make an application expression.  If the next tokens
        are an argument in parens, then the argument expression is a
        function being applied to the arguments.  Otherwise, return the
        argument expression."""
        ...
    
    def make_VariableExpression(self, name):
        ...
    


@python_2_unicode_compatible
class Expression(object):
    _linear_logic_parser = ...
    @classmethod
    def fromstring(cls, s):
        ...
    
    def applyto(self, other, other_indices: Optional[Any] = ...):
        ...
    
    def __call__(self, other):
        ...
    
    def __repr__(self):
        ...
    


@python_2_unicode_compatible
class AtomicExpression(Expression):
    def __init__(self, name, dependencies: Optional[Any] = ...):
        """
        :param name: str for the constant name
        :param dependencies: list of int for the indices on which this atom is dependent
        """
        self.name = ...
        self.dependencies = ...
    
    def simplify(self, bindings: Optional[Any] = ...):
        """
        If 'self' is bound by 'bindings', return the atomic to which it is bound.
        Otherwise, return self.

        :param bindings: ``BindingDict`` A dictionary of bindings used to simplify
        :return: ``AtomicExpression``
        """
        ...
    
    def compile_pos(self, index_counter, glueFormulaFactory):
        """
        From Iddo Lev's PhD Dissertation p108-109

        :param index_counter: ``Counter`` for unique indices
        :param glueFormulaFactory: ``GlueFormula`` for creating new glue formulas
        :return: (``Expression``,set) for the compiled linear logic and any newly created glue formulas
        """
        self.dependencies = ...
    
    def compile_neg(self, index_counter, glueFormulaFactory):
        """
        From Iddo Lev's PhD Dissertation p108-109

        :param index_counter: ``Counter`` for unique indices
        :param glueFormulaFactory: ``GlueFormula`` for creating new glue formulas
        :return: (``Expression``,set) for the compiled linear logic and any newly created glue formulas
        """
        self.dependencies = ...
    
    def initialize_labels(self, fstruct):
        self.name = ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __str__(self):
        ...
    
    def __hash__(self):
        ...
    


class ConstantExpression(AtomicExpression):
    def unify(self, other, bindings):
        """
        If 'other' is a constant, then it must be equal to 'self'.  If 'other' is a variable,
        then it must not be bound to anything other than 'self'.

        :param other: ``Expression``
        :param bindings: ``BindingDict`` A dictionary of all current bindings
        :return: ``BindingDict`` A new combined dictionary of of 'bindings' and any new binding
        :raise UnificationException: If 'self' and 'other' cannot be unified in the context of 'bindings'
        """
        ...
    


class VariableExpression(AtomicExpression):
    def unify(self, other, bindings):
        """
        'self' must not be bound to anything other than 'other'.

        :param other: ``Expression``
        :param bindings: ``BindingDict`` A dictionary of all current bindings
        :return: ``BindingDict`` A new combined dictionary of of 'bindings' and the new binding
        :raise UnificationException: If 'self' and 'other' cannot be unified in the context of 'bindings'
        """
        ...
    


@python_2_unicode_compatible
class ImpExpression(Expression):
    def __init__(self, antecedent, consequent):
        """
        :param antecedent: ``Expression`` for the antecedent
        :param consequent: ``Expression`` for the consequent
        """
        self.antecedent = ...
        self.consequent = ...
    
    def simplify(self, bindings: Optional[Any] = ...):
        ...
    
    def unify(self, other, bindings):
        """
        Both the antecedent and consequent of 'self' and 'other' must unify.

        :param other: ``ImpExpression``
        :param bindings: ``BindingDict`` A dictionary of all current bindings
        :return: ``BindingDict`` A new combined dictionary of of 'bindings' and any new bindings
        :raise UnificationException: If 'self' and 'other' cannot be unified in the context of 'bindings'
        """
        ...
    
    def compile_pos(self, index_counter, glueFormulaFactory):
        """
        From Iddo Lev's PhD Dissertation p108-109

        :param index_counter: ``Counter`` for unique indices
        :param glueFormulaFactory: ``GlueFormula`` for creating new glue formulas
        :return: (``Expression``,set) for the compiled linear logic and any newly created glue formulas
        """
        ...
    
    def compile_neg(self, index_counter, glueFormulaFactory):
        """
        From Iddo Lev's PhD Dissertation p108-109

        :param index_counter: ``Counter`` for unique indices
        :param glueFormulaFactory: ``GlueFormula`` for creating new glue formulas
        :return: (``Expression``,list of ``GlueFormula``) for the compiled linear logic and any newly created glue formulas
        """
        ...
    
    def initialize_labels(self, fstruct):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __str__(self):
        ...
    
    def __hash__(self):
        ...
    


@python_2_unicode_compatible
class ApplicationExpression(Expression):
    def __init__(self, function, argument, argument_indices: Optional[Any] = ...):
        """
        :param function: ``Expression`` for the function
        :param argument: ``Expression`` for the argument
        :param argument_indices: set for the indices of the glue formula from which the argument came
        :raise LinearLogicApplicationException: If 'function' cannot be applied to 'argument' given 'argument_indices'.
        """
        self.function = ...
        self.argument = ...
        self.bindings = ...
    
    def simplify(self, bindings: Optional[Any] = ...):
        """
        Since function is an implication, return its consequent.  There should be
        no need to check that the application is valid since the checking is done
        by the constructor.

        :param bindings: ``BindingDict`` A dictionary of bindings used to simplify
        :return: ``Expression``
        """
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __str__(self):
        ...
    
    def __hash__(self):
        ...
    


@python_2_unicode_compatible
class BindingDict(object):
    def __init__(self, bindings: Optional[Any] = ...):
        """
        :param bindings:
            list [(``VariableExpression``, ``AtomicExpression``)] to initialize the dictionary
            dict {``VariableExpression``: ``AtomicExpression``} to initialize the dictionary
        """
        self.d = ...
    
    def __setitem__(self, variable, binding):
        """
        A binding is consistent with the dict if its variable is not already bound, OR if its
        variable is already bound to its argument.

        :param variable: ``VariableExpression`` The variable bind
        :param binding: ``Expression`` The expression to which 'variable' should be bound
        :raise VariableBindingException: If the variable cannot be bound in this dictionary
        """
        ...
    
    def __getitem__(self, variable):
        """
        Return the expression to which 'variable' is bound
        """
        ...
    
    def __contains__(self, item):
        ...
    
    def __add__(self, other):
        """
        :param other: ``BindingDict`` The dict with which to combine self
        :return: ``BindingDict`` A new dict containing all the elements of both parameters
        :raise VariableBindingException: If the parameter dictionaries are not consistent with each other
        """
        ...
    
    def __ne__(self, other):
        ...
    
    def __eq__(self, other):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    


class VariableBindingException(Exception):
    ...


class UnificationException(Exception):
    def __init__(self, a, b, bindings):
        ...
    


class LinearLogicApplicationException(Exception):
    ...


def demo():
    ...

if __name__ == '__main__':
    ...
